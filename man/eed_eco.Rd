% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/constructors.R
\name{eed_eco}
\alias{eed_eco}
\title{Create an eed_eco object, containing a system of ODEs describing ecological dynamics}
\usage{
eed_eco(expr)
}
\arguments{
\item{expr}{An expression describing the ecological dynamics. The
expression can use any variable names you like, but \code{N}, \code{N_}, \code{X}, and \code{X_}
have special meaning. ``. The last statement in the expression must return a list,
where named components specify time derivatives of any variables by prefixing with
the letter 'd'. The named list must have at least one element named 'dN' or 'f',
use 'dN' to return the time derivative of 'N', the change in population sizes.
If you prefer you can return the 'f' instead, which is the per capita rate of
increase in population, which is what is used to measure fitness in \code{ecoevodynamo}.
Returning 'f' directly is often slightly more computationally efficient. Any other
variable mentioned in the expression can also have its time derivative returned, and
these variables will have their dynamics modeled in the system of ODEs as well, just
return an element with the same name as the variable but with prefixed with a 'd'. See
examples to get an idea how this works in practice. Lastly, any other named elements
besides 'f' or those that start with 'd' will be treated as global variables to be
passed to the next iteration of the model. Lastly there is one more special element that
can be passed in this list, and that is one named 'G'. This will be treated as a
dynamically calculated 'G' matrix which will be used to scale any selection gradient
calculations in a downstream `ecoevodynamo` model run (if used in an `ecodynamo` 'G'
will simply be ignored).}
}
\value{
An \code{eed_eco} object, which is essentially just a properly formatted function.
}
\description{
Create an eed_eco object, containing a system of ODEs describing ecological dynamics
}
\examples{
eed_eco({
  dists <- torch_cdist(X, X_, compute_mode = "use_mm_for_euclid_dist")
  competition <- torch_exp((-(dists^2) / (2 * comp^2)))
  weighted_pop <- torch_mm(competition, N_)
  dN_dt <- r * (1 - (weighted_pop / K))

  list(f = dN_dt)
})
}
